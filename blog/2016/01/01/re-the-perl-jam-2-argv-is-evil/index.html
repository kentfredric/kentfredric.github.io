<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
    <head>
        <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
        <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
        <link href="/theme/css/statocles-bootstrap.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Re: The Perl Jam 2: <"ARGV"> is evil - KENTNL's Blog</title>
        <meta content="Statocles 0.063" name="generator">
        <meta content="https://avatars0.githubusercontent.com/u/44790?v=3&amp;s=400" property="og:image">

        <link href="/theme/plugin/highlight/default.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <header>
            <nav class="navbar navbar-default navbar-static-top" role="navigation">
                <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                    <div class="navbar-header">
                        <button class="navbar-toggle" data-target="#top-navbar-collapse-1" data-toggle="collapse" type="button">
                            <span class="sr-only">Toggle navigation</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="/">KENTNL&#39;s Blog</a>
                    </div>
                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse" id="top-navbar-collapse-1">
                        <ul class="nav navbar-nav">
                            <li><a href="/">Blog</a></li>
                        </ul>
                        
                    </div>
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">

    <div class="col-md-9">
        <main>
            <header>
                <h1>Re: The Perl Jam 2: &lt;&quot;ARGV&quot;&gt; is evil</h1>
                <p class="tags">Tags:
                    <a href="/blog/tag/perl/" rel="tag">perl</a>
                    <a href="/blog/tag/the-perl-jam-2/" rel="tag">the perl jam 2</a>
                </p>

                <aside>
                    <p><time datetime="2016-01-01">
                        Posted on 2016-01-01
                    </time>
                    </p>
                </aside>


            </header>
            <section id="section-1">
                <p>This is part 2 in a <a href="/blog/tag/the-perl-jam-2">series</a> of responses to
<a href="https://www.youtube.com/watch?v=eH_u3C2WwQ0">Netanel Rubin&#39;s Presentation: The Perl Jam 2</a>,
for reasons explained in <a href="/blog/2015/12/31/re-the-perl-jam-2-cgi-sucks/">Part 1</a></p>

<p>This is on the list of things that Netanel would have best served the Perl
community by filing a bug when he discovered it.</p>

<h2 id="_argv_is_evil"><code>&lt;&quot;ARGV&quot;&gt;</code> is evil<a class="toplink" href="#top">^</a><a class="permalink" href="#_argv_is_evil">⚓</a></h2>

<p>Here is the most reduced code you can have that demonstrates the
vulnerability in play.</p>

<pre><code class="hljs"><span class="hljs-keyword">use</span> <span class="hljs-keyword">strict</span>;
<span class="hljs-keyword">use</span> <span class="hljs-keyword">warnings</span>;

<span class="hljs-comment"># Pretend this came in through a CGI Request Paramete</span><span class="hljs-comment">
</span><span class="hljs-variable">@ARGV</span>=( &#39;<span class="hljs-string">echo exploited|</span>&#39; );

<span class="hljs-comment"># This function should return a filehandle, but the user did something</span><span class="hljs-comment">
</span><span class="hljs-comment"># to trick magical_function to return the string &quot;ARGV&quot;</span><span class="hljs-comment">
</span>
<span class="hljs-keyword">my</span> <span class="hljs-type">$filehandle</span> = magical_function();

<span class="hljs-comment"># TRAP</span><span class="hljs-comment">
</span><span class="hljs-keyword">while</span> (&lt;<span class="hljs-type">$filehandle</span>&gt;) {
  <span class="hljs-function">print</span> <span class="hljs-variable">$_</span>;
}
</code></pre>

<p>As long as <code>$filehandle</code> is in fact a FileHandle, nothing weird happens.</p>

<p>However, when $filehandle is a <em>string</em>, Perl does something it typically
shouldn&#39;t: It treats the string as a <em>description</em> of a filehandle.</p>

<p>So for instance, if somebody had done:</p>

<pre><code class="hljs"><span class="hljs-comment"># </span>NOTE<span class="hljs-comment">: OLD STYLE CODE, DO NOT USE</span><span class="hljs-comment">
</span><span class="hljs-function">open</span> <span class="hljs-type">*WAT</span>, &#39;<span class="hljs-string">-|</span>&#39;, &#39;<span class="hljs-string">echo exploited|</span>&#39;;

<span class="hljs-keyword">my</span> <span class="hljs-type">$filehandle</span> = &quot;<span class="hljs-string">WAT</span>&quot;;

<span class="hljs-keyword">while</span>(&lt;<span class="hljs-type">$filehandle</span>&gt;) {  }
</code></pre>

<p>Perl behaves as if you&#39;d written:</p>

<pre><code class="hljs"><span class="hljs-comment"># </span>NOTE<span class="hljs-comment">: OLD STYLE CODE, DO NOT USE</span><span class="hljs-comment">
</span><span class="hljs-function">open</span> <span class="hljs-type">*WAT</span>, &#39;<span class="hljs-string">-|</span>&#39;, &#39;<span class="hljs-string">echo exploited|</span>&#39;;

<span class="hljs-keyword">my</span> <span class="hljs-type">$filehandle</span> = &quot;<span class="hljs-string">WAT</span>&quot;;

<span class="hljs-keyword">while</span>(<span class="hljs-keyword">&lt;WAT&gt;</span>) {  }
</code></pre>

<p>In other Perl structures, this sort of transformation would be the kind of
forbidden behaviour <code>strict</code> guards against:</p>

<pre><code class="hljs"><span class="hljs-keyword">use</span> <span class="hljs-keyword">strict</span>;
<span class="hljs-keyword">use</span> <span class="hljs-keyword">warnings</span>;

<span class="hljs-function">open</span> <span class="hljs-type">*WAT</span>, &#39;<span class="hljs-string">|-</span>&#39;, &#39;<span class="hljs-string">cat</span>&#39;;
<span class="hljs-keyword">my</span> <span class="hljs-type">$handle</span> = &#39;<span class="hljs-string">WAT</span>&#39;;

<span class="hljs-function">print</span> { <span class="hljs-type">$handle</span> } &quot;<span class="hljs-string">Hi there</span>&quot;;
<span class="hljs-comment"># Can&#39;t use string (&quot;WAT&quot;) as a symbol ref while &quot;strict refs&quot; in use</span><span class="hljs-comment">
</span></code></pre>

<p>But the special value <code>ARGV</code> gets additionally complicated because it is
&quot;Magic&quot; to <code>&lt;&gt;</code></p>

<blockquote>
<pre><code>ARGV    The special filehandle that iterates over command-line filenames
        in @ARGV. Usually written as the null filehandle in the angle
        operator &quot;&lt;&gt;&quot;. Note that currently &quot;ARGV&quot; only has its magical
        effect within the &quot;&lt;&gt;&quot; operator; elsewhere it is just a plain
        filehandle corresponding to the last file opened by &quot;&lt;&gt;&quot;. In
        particular, passing &quot;\*ARGV&quot; as a parameter to a function that
        expects a filehandle may not cause your function to automatically
        read the contents of all the files in @ARGV.
</code></pre>
</blockquote>

<p>And that feature is implemented in terms of:</p>

<pre><code class="hljs"><span class="hljs-keyword">foreach</span> <span class="hljs-keyword">my</span> <span class="hljs-type">$file</span> ( <span class="hljs-variable">@ARGV</span> ) {
    <span class="hljs-function">open</span> <span class="hljs-keyword">my</span> <span class="hljs-type">$fh</span>, <span class="hljs-type">$file</span>;
}
</code></pre>

<p>And that invokes the 2-arg-open magic, which means</p>

<pre><code class="hljs"><span class="hljs-function">open</span> <span class="hljs-keyword">my</span> <span class="hljs-type">$fh</span>, &quot;<span class="hljs-string">echo hello |</span>&quot;
</code></pre>

<p>Excutes <code>echo hello</code> and emits its output into the filehandle <code>$fh</code>.</p>

<p>This specific feature is just one of those conveniences that makes a lot of
sense on the command line where you can trust the person who populated
<code>@ARGV</code> is also you.</p>

<p>It allows you do to neat things like</p>

<pre><code class="hljs"><span class="hljs-comment"># read all of stdin, then read a file when stdin is empty</span><span class="hljs-comment">
</span><span class="hljs-built-in">echo</span> foo <span class="hljs-keyword">|</span> perl ./script.pl \
                    - \
                    ./source_file_2

<span class="hljs-comment"># read all of file one, then all of file 2</span><span class="hljs-comment">
</span>perl ./script.pl \
          ./sourcefile_1 \
          ./source_file_2

<span class="hljs-comment"># read all of files 1 and 2, and then read source file 3 while</span><span class="hljs-comment">
</span><span class="hljs-comment"># decompressing it</span><span class="hljs-comment">
</span>perl ./script.pl \
      ./source_file_1 \
      ./source_file_2 \
      <span class="hljs-string">&#39;gzcat ./source_file_3|&#39;</span>
</code></pre>

<p>But this feature makes <strong>NO</strong> sense when you&#39;re on the internet using CGI, and the person passing your command line arguments is some person with an HTTP Client.</p>

<p>So on the Web using CGI, <code>strict</code> not doing its job escalates the problem to a security hole.</p>

<h2 id="how_do_we_fix_it_">How do we fix it?<a class="toplink" href="#top">^</a><a class="permalink" href="#how_do_we_fix_it_">⚓</a></h2>

<h3 id="locking_it_up_with_strictures">Locking it up with strictures<a class="toplink" href="#top">^</a><a class="permalink" href="#locking_it_up_with_strictures">⚓</a></h3>

<p><code>use strict</code> really aught to imply <code>strict</code> here, and <code>&lt;&quot;ANYTHING&quot;&gt;</code> should subsequently be a strictures error. Adding that change however risks
breaking existing code with real world usecases, so a painful deprecation cycle might be necessary somehow.</p>

<p>Either way, I saw some hackers looking in to fixing this on <code>irc.perl.org#p5p</code> within minutes of it being presented.</p>

<h3 id="encouragement_of_using_instead_of_">Encouragement of using <code>&lt;&lt;&gt;&gt;</code> instead of <code>&lt;&gt;</code><a class="toplink" href="#top">^</a><a class="permalink" href="#encouragement_of_using_instead_of_">⚓</a></h3>

<p>Perl has recognised the potential for risks associated with 2-argument open for a while,
and the recommendation of 3-argument open has been standard fare in Perl Communities for a very long time now.</p>

<p>As the the risk implied by</p>

<pre><code class="hljs"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">&lt;ARGV&gt;</span>) { }
</code></pre>

<p>Is the same as the risk implied by</p>

<pre><code class="hljs"><span class="hljs-keyword">while</span>(&lt;&gt;) { }
</code></pre>

<p>We now have a feature since perl <code>5.22</code> that retains the ability to read files from <code>ARGV</code> without the risk
of one of those files executing arbitrary code.</p>

<pre><code class="hljs"><span class="hljs-keyword">while</span>(&lt;&lt;&gt;&gt;) { }
</code></pre>

<p>And this should be encouraged in production quality code instead of either <code>&lt;&gt;</code> or <code>&lt;ARGV&gt;</code>.</p>

<p>This fact is useless in our specific case of <code>&lt;$VARIABLE&gt;</code> mind, because</p>

<pre><code class="hljs"><span class="hljs-comment"># invalid, parsed as &lt;&lt;&quot;ARGV&quot; &gt;&gt; where &quot;ARGV&quot; is a heredoc terminator</span><span class="hljs-comment">
</span><span class="hljs-keyword">while</span>(&lt;&lt;<span class="hljs-keyword">ARGV</span><span class="hljs-string">&gt;&gt;)</span><span class="hljs-string">
</span><span class="hljs-string">
</span><span class="hljs-string"># invalid, parsed as &lt;&lt;&quot;&quot; </span><span class="hljs-type">$filename</span><span class="hljs-string">&gt;&gt; where &quot;&quot; is a heredoc terminator</span><span class="hljs-string">
</span><span class="hljs-string">while(&lt;&lt;</span><span class="hljs-type">$filehandle</span><span class="hljs-string">&gt;&gt;)</span><span class="hljs-string">
</span></code></pre>

<p>But its worth keeping in consideration.</p>

<h3 id="locking_up_the_argv_iterator_">Locking up the <code>ARGV</code> iterator.<a class="toplink" href="#top">^</a><a class="permalink" href="#locking_up_the_argv_iterator_">⚓</a></h3>

<p>The deeper question is wether or not the ARGV iterator is something that should be deemed &quot;Sane&quot; in 2015.
I&#39;ve clearly demonstrate it <em>can</em> be useful, but its also easy to demonstrate how it <em>can</em> pose a security
risk in the event anyone is foolish enough to use <code>&lt;&gt;</code> or <code>&lt;ARGV&gt;</code> without fully realising the consequences.
And this can be hard to even realise is a problem in a code security review.</p>

<p>Were it me, given the lethality of those features, I would be wanting to deprecate both of those outside <code>perl -e</code>,
which I believe is its primary usecase anyway, because it eliminates the need for multiple layers of quoting and lots
of painful explicit calls to <code>open()</code>, which would grossly burden somebody who is simply trying to string together a short oneliner.</p>

<pre><code class="hljs">perl -e <span class="hljs-string">&#39;while(&lt;&gt;) { print $_ }&#39;</span> <span class="hljs-string">&#39;file_a.txt&#39;</span> <span class="hljs-string">&#39;gzcat file_b.txt|&#39;</span> <span class="hljs-string">&#39;-&#39;</span>
</code></pre>

<p>This code without the magic of <code>&lt;&gt;</code> and <code>ARGV</code> gives you a significant amount of code to write.
So much in fact, that simply thinking about what it would take made me give up even tempting to write one as an example in Perl, so instead,
an equivalent in bash will have to suffice:</p>

<pre><code class="hljs">cat file_a.txt &lt;( gzcat file_b.txt ) /dev/stdin
</code></pre>

<p>Maybe we can develop a pragma that regulates what 2-arg <code>open</code> ( and its effective internals in ARGV ) are permitted to do?
ie:</p>

<pre><code class="hljs"><span class="hljs-keyword">use</span> <span class="hljs-function">Safe::Open2</span>; <span class="hljs-comment"># 2-arg-open assumes *all* arguments are filenames</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Safe::Open2</span> qw/stdio/; <span class="hljs-comment"># as with ^, but allows - based STDIO access</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Safe::Open2</span> qw/exec stdio/; <span class="hljs-comment"># allows pipe-exec and stdio</span><span class="hljs-comment">
</span></code></pre>

<p>I don&#39;t honestly know, and its messy, becuase you can&#39;t really afford to turn it on/off on a per-module basis, because the security
risk has global implications regardless of where you write it, as its fundementally dealing with the gateway perl uses to interact with the rest
of the operating system.</p>

<p>So something with only lexical effect would be still born, but something with global effect could cause spooky action at a distance,
because <code>ARGV</code> is implicitly global in nature, and unresolvably so.</p>

<p>But either way</p>

<ul>
<li>It makes sense to have this feature when you <strong>know</strong> you&#39;re working in a command line directly in a secure environement</li>
<li>It makes much less sense to a have this feature when you&#39;re not intending to work with the command line, or you&#39;re dealing with mixed environment security</li>
</ul>

<h2 id="comments">Comments<a class="toplink" href="#top">^</a><a class="permalink" href="#comments">⚓</a></h2>

<p>Please direct any feedback or corrections <a href="https://www.reddit.com/r/perl/comments/3yzkjq/re_the_perl_jam_2_argv_is_evil/">to the Reddit thread</a>. Alternatively, message me on irc:</p>

<ul>
<li>irc.perl.org u:kentnl</li>
<li>irc.freenode.org u:kent\n</li>
</ul>

<p>Or if you want, you can <a href="https://github.com/kentfredric/kentfredric.github.io/pulls">patch the blog yourself</a>
or <a href="https://github.com/kentfredric/kentfredric.github.io/issues">file a bug on it</a></p>

            </section>
        </main>


    </div>

    <div class="col-md-3">
        
        <nav id="tags">
            <h1>Tags</h1>
            <ul class="list-inline">
                <li><a href="/blog/tag/perl/">perl</a></li>
                <li><a href="/blog/tag/the-perl-jam-2/">the perl jam 2</a></li>
            </ul>
        </nav>
    </div>

</div>

        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
